import{A as s,l,c as i,u}from"./index-D4ngco80.js";import"./react-vendor-Dazix4UH.js";async function d(){try{const e=new AbortController,t=setTimeout(()=>e.abort(),5e3),r=await fetch(`${s}/api/health`,{method:"GET",headers:{"Content-Type":"application/json"},signal:e.signal});if(clearTimeout(t),!r.ok)return{isHealthy:!1,isLoading:!0,error:`Server returned ${r.status}`};const a=await r.json();if(a.status!=="ok")return{isHealthy:!1,isLoading:!0,error:"Server status is not OK"};if(a.memory){const o=parseInt(a.memory.heapUsed.replace("MB","")),c=parseInt(a.memory.heapTotal.replace("MB",""));if(c>0)return{isHealthy:!0,isLoading:o/c*100>80,memoryUsage:a.memory,uptime:a.uptime}}return{isHealthy:!0,isLoading:!1,memoryUsage:a.memory,uptime:a.uptime}}catch(e){const t=e.name==="AbortError"?"Server health check timed out":e.message||"Failed to check server health";return console.warn("Server health check failed:",t),{isHealthy:!1,isLoading:!0,error:t}}}function h(e,t=5){if(!e)return!0;const r=new Date(e);return(new Date().getTime()-r.getTime())/(1e3*60*60*24)>=t}const m=5;async function g(e){try{console.log(`[Recalculation] Starting recalculation for bucket: ${e.name}`);const t=await i(e.funds),r={...e,performance:{...e.performance,rollingReturns:t.rollingReturns,analysisStartDate:t.analysisStartDate,analysisEndDate:t.analysisEndDate,totalPeriods:t.totalPeriods},lastCalculationDate:new Date().toISOString(),updatedAt:new Date().toISOString()};return await u(e.id,r),console.log(`[Recalculation] Successfully recalculated bucket: ${e.name}`),r}catch(t){return console.error(`[Recalculation] Error recalculating bucket ${e.name}:`,t.message),null}}async function k(){const e={checked:0,recalculated:0,skipped:0,errors:0};try{const t=await d();if(!t.isHealthy)return console.log("[Recalculation] Server is not healthy, skipping recalculation"),e;if(t.isLoading)return console.log("[Recalculation] Server is under load, skipping recalculation"),e;console.log("[Recalculation] Server is healthy, checking buckets...");const a=(await l(!1)).filter(o=>(e.checked++,o.isActive&&h(o.lastCalculationDate,m)));if(a.length===0)return console.log("[Recalculation] No buckets need recalculation"),e;console.log(`[Recalculation] Found ${a.length} buckets that need recalculation`);for(const o of a)await g(o)?e.recalculated++:e.errors++,await new Promise(n=>setTimeout(n,1e3));return console.log(`[Recalculation] Completed: ${e.recalculated} recalculated, ${e.errors} errors`),e}catch(t){return console.error("[Recalculation] Error in checkAndRecalculateBuckets:",t.message),e}}export{k as checkAndRecalculateBuckets};
